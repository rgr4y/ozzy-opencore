#!/usr/bin/env python3.11
"""
Ozzy - macOS OpenCore Remote Deploy Master Script

A lean command orchestrator that delegates to specialized scripts and workflows.
Focused on the core use cases: apply changesets, build ISOs/USBs, deploy to Proxmox.
"""

import sys
import subprocess
import argparse
from pathlib import Path

# Add lib directory to path
sys.path.insert(0, str(Path(__file__).resolve().parent / 'lib'))

# Import basic utilities
from lib import ROOT, log, warn, error, info, list_available_changesets, list_newest_changesets

def run_script(script_path, args_list, description):
    """Run a script with the given arguments"""
    cmd = [sys.executable, str(script_path)] + args_list
    log(f"Running: {' '.join(cmd)}")
    
    try:
        result = subprocess.run(cmd, cwd=ROOT, check=True)
        return True
    except subprocess.CalledProcessError as e:
        error(f"{description} failed with exit code {e.returncode}")
        return False
    except Exception as e:
        error(f"Failed to run {description}: {e}")
        return False

def check_python_env():
    """Check if Python environment has required packages"""
    try:
        import yaml
        import plistlib
        return True
    except ImportError:
        return False

def normalize_changeset_name(changeset_name):
    """Strip .yaml extension from changeset name if present"""
    if changeset_name.endswith('.yaml'):
        return changeset_name[:-5]
    return changeset_name

def requires_python_env(func):
    """Decorator to check Python environment before running command"""
    def wrapper(*args, **kwargs):
        if not check_python_env():
            warn("Python environment not ready. Run: ./ozzy setup-env")
            return False
        return func(*args, **kwargs)
    return wrapper

def build_script_args(args, base_args=None, extra_args=None, flags=None, changeset_first=True):
    """Build command arguments from args object with common patterns"""
    cmd_args = list(base_args) if base_args else []
    
    # Add changeset if present and should be first
    if changeset_first and hasattr(args, 'changeset') and args.changeset:
        changeset_name = normalize_changeset_name(args.changeset)
        cmd_args.insert(0, changeset_name)
    
    # Add output if present
    if hasattr(args, 'output') and args.output:
        cmd_args.extend(['--output', args.output])
    
    # Add common flags
    if flags:
        for flag in flags:
            if getattr(args, flag.replace('-', '_'), False):
                cmd_args.append(f'--{flag}')
    
    # Add any extra arguments
    if extra_args:
        cmd_args.extend(extra_args)
    
    return cmd_args

def run_script_command(script_path, args, description, base_args=None, extra_args=None, flags=None, changeset_first=True):
    """Run a script with standardized argument handling"""
    cmd_args = build_script_args(args, base_args, extra_args, flags, changeset_first)
    return run_script(script_path, cmd_args, description)

# Command implementations
@requires_python_env
def cmd_apply(args, extra_args=None):
    """Apply a changeset to OpenCore configuration"""
    script = ROOT / "scripts" / "apply-changeset.py"
    changeset_name = normalize_changeset_name(args.changeset)
    cmd_args = [changeset_name]
    if extra_args:
        cmd_args.extend(extra_args)
    return run_script(script, cmd_args, "Apply changeset")

@requires_python_env
def cmd_build_iso(args):
    """Build OpenCore ISO"""
    script = ROOT / "scripts" / "build-iso.py"
    return run_script_command(script, args, "Build ISO", 
                             flags=['force', 'no-validate'])

@requires_python_env
def cmd_build_usb(args):
    """Build USB EFI structure"""
    script = ROOT / "scripts" / "build-usb.py"
    return run_script_command(script, args, "Build USB", 
                             flags=['force'])

def cmd_validate(args):
    """Validate OpenCore configuration"""
    script = ROOT / "scripts" / "validate-config.py"
    cmd_args = [args.config] if args.config else []
    return run_script(script, cmd_args, "Validate configuration")

@requires_python_env
def cmd_generate_smbios(args):
    """Generate SMBIOS data"""
    script = ROOT / "scripts" / "generate-serial.py"
    return run_script_command(script, args, "Generate SMBIOS", 
                             flags=['force'])

@requires_python_env
def cmd_generate_serial(args):
    """Generate serial numbers and UUIDs"""
    script = ROOT / "scripts" / "generate-serial.py"
    cmd_args = []
    
    if args.changeset:
        changeset_name = normalize_changeset_name(args.changeset)
        cmd_args.append(changeset_name)
    
    # Add flags
    for flag in ['force', 'list', 'serial-only', 'rom-uuid-only']:
        attr_name = flag.replace('-', '_')
        if getattr(args, attr_name, False):
            cmd_args.append(f'--{flag}')
    
    return run_script(script, cmd_args, "Generate serial numbers")

@requires_python_env
def cmd_read_config(args):
    """Read existing config.plist and convert to changeset format"""
    script = ROOT / "scripts" / "read-config.py"
    return run_script_command(script, args, "Read config", 
                             base_args=[args.config], changeset_first=False)

# Workflow commands
@requires_python_env
def cmd_full_usb(args):
    """Full USB workflow: changeset → ISO → USB"""
    workflow = ROOT / "workflows" / "full-usb.py"
    return run_script_command(workflow, args, "Full USB workflow", 
                             flags=['force', 'eject'])

@requires_python_env
def cmd_full_deploy(args):
    """Full deploy workflow: changeset → IMG/ISO → Proxmox"""
    # Validate argument combinations
    if getattr(args, 'iso_only', False) and getattr(args, 'force', False):
        error("Cannot use --iso-only and --force together. --iso-only skips the apply step, making --force redundant.")
        return False
    
    workflow = ROOT / "workflows" / "full-deploy.py"
    return run_script_command(workflow, args, "Full deploy workflow", 
                             flags=['force', 'build-only', 'iso-only', 'iso'])

@requires_python_env
def cmd_switch(args):
    """Switch changeset for testing"""
    workflow = ROOT / "workflows" / "switch-changeset.py"
    return run_script_command(workflow, args, "Switch changeset", 
                             flags=['force'])

# Utility commands
def cmd_fetch(args):
    """Fetch OpenCore assets"""
    script = ROOT / "scripts" / "fetch-assets.py"
    return run_script(script, [], "Fetch assets")

def cmd_clean(args):
    """Clean output directories"""
    import shutil
    
    out_dir = ROOT / "out"
    if out_dir.exists():
        log("Cleaning output directory...")
        for item in out_dir.iterdir():
            if item.is_dir():
                shutil.rmtree(item)
            else:
                item.unlink()
        log("Clean completed")
    else:
        info("No output directory to clean")
    return True

def cmd_setup_env(args):
    """Set up Python environment"""
    script = ROOT / "bin" / "setup_env.sh"
    try:
        result = subprocess.run(['bash', str(script)], cwd=ROOT, check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def display_changesets(changesets, title="Available changesets"):
    """Display a list of changesets in a consistent format"""
    if changesets:
        log(f"{title}:")
        for cs in sorted(changesets):
            info(f"  - {cs}")
    else:
        warn("No changesets found")

def cmd_status(args):
    """Show project status"""
    log("Project Status")
    
    # Basic info
    info(f"Project Root: {ROOT}")
    info(f"Output Directory: {ROOT / 'out'}")
    
    # Python environment
    python_ok = check_python_env()
    python_status = "✓" if python_ok else "✗"
    info(f"Python Environment: {python_status}")
    
    # Available changesets
    changesets = list_available_changesets()
    display_changesets(changesets)
    
    # Check key files
    config_file = ROOT / "out" / "build" / "efi" / "EFI" / "OC" / "config.plist"
    config_status = "✓" if config_file.exists() else "✗"
    info(f"Current Config: {config_status} {config_file}")
    
    return True

def cmd_mount_efi(args):
    """Mount EFI partition from Install USB or USB drives with EFI partitions"""
    import subprocess
    import glob
    
    log("Scanning for USB drives with EFI partitions...")
    
    # First priority: Find Install volumes
    volumes_pattern = "/Volumes/Install*"
    install_volumes = []
    
    log("Scanning for Install volumes...")
    for volume_path in glob.glob(volumes_pattern):
        volume = Path(volume_path)
        if volume.exists() and volume.is_dir():
            log(f"Found Install volume: {volume}")
            install_volumes.append(volume)
    
    # If Install volumes found, use them (original behavior)
    if install_volumes:
        if len(install_volumes) > 1:
            log("Multiple Install volumes found:")
            for i, volume in enumerate(install_volumes, 1):
                log(f"  {i}. {volume}")
            log("Using the first one found")
        
        # Use the first Install volume
        install_volume = install_volumes[0]
        log(f"Using Install volume: {install_volume}")
        
        # Get disk identifier
        try:
            result = subprocess.run(['diskutil', 'info', str(install_volume)], 
                                  capture_output=True, text=True, check=True)
            
            disk_id = None
            for line in result.stdout.split('\n'):
                if 'Device Identifier:' in line:
                    disk_id = line.split(':')[1].strip()
                    break
                    
            if not disk_id:
                error("Could not determine disk identifier")
                return False
                
        except subprocess.CalledProcessError as e:
            error(f"Failed to get disk info for {install_volume}: {e.stderr}")
            return False
        
        # Extract base disk (e.g., disk2s2 -> disk2)
        selected_disk = disk_id.rsplit('s', 1)[0]
        log(f"Using disk from Install volume: {selected_disk}")
        
    else:
        # Fallback: Look for USB drives with EFI partitions only
        log("No Install volumes found, scanning for USB drives with EFI partitions...")
        usb_disks = []
        
        try:
            # Get list of all disks
            result = subprocess.run(['diskutil', 'list'], capture_output=True, text=True, check=True)
            
            # Parse diskutil output to find USB/external disks
            current_disk = None
            for line in result.stdout.split('\n'):
                line = line.strip()
                if line.startswith('/dev/disk'):
                    current_disk = line.split()[0].replace('/dev/', '')
                elif current_disk and ('external' in line.lower() or 'usb' in line.lower()):
                    # Get detailed info about this disk
                    try:
                        disk_info = subprocess.run(['diskutil', 'info', current_disk], 
                                                 capture_output=True, text=True, check=True)
                        
                        # Check if it's removable/external (USB only, not internal drives)
                        is_removable = False
                        protocol_usb = False
                        for info_line in disk_info.stdout.split('\n'):
                            if 'Removable Media:' in info_line and 'Yes' in info_line:
                                is_removable = True
                            if 'Protocol:' in info_line and 'USB' in info_line:
                                protocol_usb = True
                        
                        # Only consider USB drives, not other external drives like Thunderbolt
                        if is_removable and protocol_usb:
                            # Check if this disk has an EFI partition (s1)
                            efi_partition = f"{current_disk}s1"
                            try:
                                efi_info = subprocess.run(['diskutil', 'info', efi_partition], 
                                                        capture_output=True, text=True, check=True)
                                
                                # Check if it's an EFI partition
                                is_efi = False
                                for efi_line in efi_info.stdout.split('\n'):
                                    if ('File System Personality:' in efi_line and 'FAT32' in efi_line) or \
                                       ('Volume Name:' in efi_line and 'EFI' in efi_line) or \
                                       ('Partition Type:' in efi_line and 'EFI' in efi_line):
                                        is_efi = True
                                        break
                                
                                if is_efi:
                                    log(f"Found USB drive with EFI partition: {current_disk}")
                                    usb_disks.append(current_disk)
                                    
                            except subprocess.CalledProcessError:
                                # No EFI partition found on this disk
                                pass
                                
                    except subprocess.CalledProcessError:
                        # Failed to get disk info
                        pass
                        
        except subprocess.CalledProcessError as e:
            warn(f"Failed to scan for USB drives: {e}")
        
        if not usb_disks:
            error("!!! No Install USB or USB drives with EFI partitions found !!!")
            error("    Either plug in a USB drive with an EFI partition, or check if EFI partition exists")
            return False
        
        # Select USB disk to use
        if len(usb_disks) > 1:
            log("Multiple USB drives with EFI partitions found:")
            for i, disk in enumerate(usb_disks, 1):
                log(f"  {i}. USB drive: /dev/{disk}")
            log("Using the first one found")
        
        selected_disk = usb_disks[0]
        log(f"Using USB drive: {selected_disk}")
    
    # Common EFI mounting logic for both Install volumes and USB drives
    
    log(f"Using disk: {selected_disk}")
    
    # Check if EFI partition exists
    efi_disk_id = f"{selected_disk}s1"  # EFI is usually partition 1
    
    try:
        result = subprocess.run(['diskutil', 'info', efi_disk_id], 
                              capture_output=True, text=True, check=True)
        
        # Check if it's actually an EFI partition
        is_efi = False
        for line in result.stdout.split('\n'):
            if 'File System Personality:' in line and 'FAT32' in line:
                is_efi = True
                break
            if 'Volume Name:' in line and 'EFI' in line:
                is_efi = True
                break
                
        if not is_efi:
            error("EFI partition not found on this disk")
            return False
            
    except subprocess.CalledProcessError:
        error("EFI partition not found on this disk")
        return False
    
    # Mount EFI partition
    try:
        result = subprocess.run(['sudo', 'diskutil', 'mount', efi_disk_id],
                              capture_output=True, text=True, check=True)
        
        # Check if EFI partition is mounted
        efi_mount_point = Path("/Volumes/EFI")
        if efi_mount_point.exists():
            log(f"✓ EFI partition mounted successfully at: {efi_mount_point}")
            info(f"You can now access the EFI partition at: {efi_mount_point}")
            
            # Show current EFI contents if it exists
            efi_folder = efi_mount_point / "EFI"
            if efi_folder.exists():
                log("Current EFI structure:")
                try:
                    result = subprocess.run(['find', str(efi_folder), '-maxdepth', '2'], 
                                          capture_output=True, text=True, check=True)
                    for line in result.stdout.strip().split('\n'):
                        if line != str(efi_folder):
                            relative_path = line.replace(str(efi_folder), '').lstrip('/')
                            if relative_path:
                                info(f"  {relative_path}")
                except subprocess.CalledProcessError:
                    pass
            else:
                info("EFI folder not found on this partition")
            
            return True
        else:
            error("EFI partition mounted but /Volumes/EFI not found")
            return False
            
    except subprocess.CalledProcessError as e:
        error(f"Failed to mount EFI partition {efi_disk_id}: {e.stderr}")
        return False

def cmd_list(args):
    """List available changesets"""
    changesets = list_available_changesets()
    display_changesets(changesets)
    return True

@requires_python_env
def cmd_test(args):
    """Run the test suite"""
    test_runner = ROOT / "tests" / "run-tests.py"
    return run_script(test_runner, [], "Test suite")

def main():
    parser = argparse.ArgumentParser(
        description='Ozzy - OpenCore Remote Deploy Master Script',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Core Commands:
  apply              Apply a changeset to OpenCore configuration
  build-iso          Build OpenCore ISO
  build-usb          Build USB EFI structure
  validate           Validate OpenCore configuration

Workflow Commands (Main Use Cases):
  full-usb           Changeset → ISO → USB in one command
  full-deploy        Changeset → IMG → Proxmox in one command
  switch             Switch to different changeset for testing

Utility Commands:
  generate-smbios    Generate SMBIOS data for changeset (serial, MLB, UUID, ROM)
  generate-serial    Generate serial numbers and UUIDs (supports --serial-only and --rom-uuid-only)
  read-config        Convert existing config.plist to changeset format
  fetch              Fetch OpenCore assets
  clean              Clean output directories
  setup-env          Set up Python environment
  status             Show project status
  list               List available changesets
  test               Run integration test suite

Examples:
  ./ozzy full-usb myconfig --output ./usb
  ./ozzy full-deploy myconfig --force
  ./ozzy full-deploy myconfig --build-only
  ./ozzy full-deploy myconfig --iso
  ./ozzy full-deploy myconfig --iso-only  # Skip changeset apply, just build & deploy
  ./ozzy switch testconfig
  ./ozzy generate-serial myconfig --force
  ./ozzy generate-serial myconfig --serial-only  # Only regenerate serial/MLB
  ./ozzy generate-serial myconfig --rom-uuid-only  # Only regenerate ROM/UUID
  ./ozzy read-config ./path/to/config.plist --output myconfig.yaml
  ./ozzy apply myconfig && ./ozzy build-iso
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Core commands
    apply_parser = subparsers.add_parser('apply', help='Apply changeset')
    apply_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    
    build_iso_parser = subparsers.add_parser('build-iso', help='Build ISO')
    build_iso_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    build_iso_parser.add_argument('--force', '-f', action='store_true', help='Force rebuild')
    build_iso_parser.add_argument('--no-validate', action='store_true', help='Skip validation')
    
    build_usb_parser = subparsers.add_parser('build-usb', help='Build USB')
    build_usb_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    build_usb_parser.add_argument('--output', '-o', help='Output directory')
    build_usb_parser.add_argument('--force', '-f', action='store_true', help='Force rebuild')
    
    validate_parser = subparsers.add_parser('validate', help='Validate config')
    validate_parser.add_argument('config', nargs='?', help='Config file path')
    
    smbios_parser = subparsers.add_parser('generate-smbios', help='Generate SMBIOS')
    smbios_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    smbios_parser.add_argument('--force', '-f', action='store_true', help='Force generation even if values are not placeholders')
    
    # Serial generation command
    serial_parser = subparsers.add_parser('generate-serial', help='Generate serial numbers')
    serial_parser.add_argument('changeset', nargs='?', help='Changeset name (without .yaml)')
    serial_parser.add_argument('--force', '-f', action='store_true', help='Force regeneration')
    serial_parser.add_argument('--list', '-l', action='store_true', help='List existing serials')
    serial_parser.add_argument('--serial-only', '-s', action='store_true', help='Only regenerate serial and MLB')
    serial_parser.add_argument('--rom-uuid-only', '-r', action='store_true', help='Only regenerate ROM and UUID')
    
    # Config reading command
    read_config_parser = subparsers.add_parser('read-config', help='Convert config.plist to changeset')
    read_config_parser.add_argument('config', help='Path to config.plist file')
    read_config_parser.add_argument('--output', '-o', help='Output changeset file')
    
    # Workflow commands
    full_usb_parser = subparsers.add_parser('full-usb', help='Full USB workflow')
    full_usb_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    full_usb_parser.add_argument('--output', '-o', help='Output directory')
    full_usb_parser.add_argument('--force', '-f', action='store_true', help='Force rebuild')
    full_usb_parser.add_argument('--eject', action='store_true', help='Automatically eject EFI and Install volumes')
    
    full_deploy_parser = subparsers.add_parser('full-deploy', help='Build IMG and deploy to Proxmox VM')
    full_deploy_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    full_deploy_parser.add_argument('--force', '-f', action='store_true', help='Force rebuild of IMG/ISO')
    full_deploy_parser.add_argument('--build-only', '-b', action='store_true', help='Build only, do not deploy')
    full_deploy_parser.add_argument('--iso-only', '-i', action='store_true', help='Skip fetch/apply/validation, build ISO and deploy only')
    full_deploy_parser.add_argument('--iso', action='store_true', help='Build ISO instead of IMG (default is IMG)')
    
    switch_parser = subparsers.add_parser('switch', help='Switch changeset')
    switch_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    switch_parser.add_argument('--force', '-f', action='store_true', help='Skip confirmation')
    
    # Utility commands
    fetch_parser = subparsers.add_parser('fetch', help='Fetch assets')
    clean_parser = subparsers.add_parser('clean', help='Clean outputs')
    setup_parser = subparsers.add_parser('setup-env', help='Setup environment')
    status_parser = subparsers.add_parser('status', help='Show status')
    list_parser = subparsers.add_parser('list', help='List changesets')
    mount_efi_parser = subparsers.add_parser('mount-efi', help='Mount EFI partition from Install USB')
    test_parser = subparsers.add_parser('test', help='Run integration test suite')
    
    args, unknown_args = parser.parse_known_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    # Command mapping
    commands = {
        'apply': cmd_apply,
        'build-iso': cmd_build_iso,
        'build-usb': cmd_build_usb,
        'validate': cmd_validate,
        'generate-smbios': cmd_generate_smbios,
        'generate-serial': cmd_generate_serial,
        'read-config': cmd_read_config,
        'full-usb': cmd_full_usb,
        'full-deploy': cmd_full_deploy,
        'switch': cmd_switch,
        'fetch': cmd_fetch,
        'clean': cmd_clean,
        'setup-env': cmd_setup_env,
        'status': cmd_status,
        'list': cmd_list,
        'mount-efi': cmd_mount_efi,
        'test': cmd_test,
    }
    
    cmd_func = commands.get(args.command)
    if not cmd_func:
        error(f"Unknown command: {args.command}")
        return 1
    
    try:
        # For apply command, pass through unknown arguments
        if args.command == 'apply':
            success = cmd_func(args, unknown_args)
        else:
            # For other commands, warn about unknown arguments
            if unknown_args:
                warn(f"Unknown arguments ignored: {' '.join(unknown_args)}")
            success = cmd_func(args)
        return 0 if success else 1
    except KeyboardInterrupt:
        warn("Operation cancelled by user")
        return 1
    except Exception as e:
        error(f"Command failed: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())
