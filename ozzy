#!/usr/bin/env python3.11
"""
Ozzy - macOS OpenCore Remote Deploy Master Script

A lean command orchestrator that delegates to specialized scripts and workflows.
Focused on the core use cases: apply changesets, build ISOs/USBs, deploy to Proxmox.
"""

import sys
import subprocess
import argparse
from pathlib import Path

# Add lib directory to path
sys.path.insert(0, str(Path(__file__).resolve().parent / 'lib'))

# Import basic utilities
from lib import ROOT, log, warn, error, info, list_available_changesets

def run_script(script_path, args_list, description):
    """Run a script with the given arguments"""
    cmd = [sys.executable, str(script_path)] + args_list
    log(f"Running: {' '.join(cmd)}")
    
    try:
        result = subprocess.run(cmd, cwd=ROOT, check=True)
        return True
    except subprocess.CalledProcessError as e:
        error(f"{description} failed with exit code {e.returncode}")
        return False
    except Exception as e:
        error(f"Failed to run {description}: {e}")
        return False

def run_workflow(workflow_path, args_list, description):
    """Run a workflow script with the given arguments"""
    return run_script(workflow_path, args_list, description)

def check_python_env():
    """Check if Python environment has required packages"""
    try:
        import yaml
        import plistlib
        return True
    except ImportError:
        return False

def normalize_changeset_name(changeset_name):
    """Strip .yaml extension from changeset name if present"""
    if changeset_name.endswith('.yaml'):
        return changeset_name[:-5]
    return changeset_name

# Command implementations
def cmd_apply(args):
    """Apply a changeset to OpenCore configuration"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    script = ROOT / "scripts" / "apply-changeset.py"
    changeset_name = normalize_changeset_name(args.changeset)
    return run_script(script, [changeset_name], "Apply changeset")

def cmd_build_iso(args):
    """Build OpenCore ISO"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    script = ROOT / "scripts" / "build-iso.py"
    cmd_args = []
    if getattr(args, 'force', False):
        cmd_args.append('--force')
    return run_script(script, cmd_args, "Build ISO")

def cmd_build_usb(args):
    """Build USB EFI structure"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    script = ROOT / "scripts" / "build-usb.py"
    cmd_args = []
    if args.changeset:
        changeset_name = normalize_changeset_name(args.changeset)
        cmd_args.extend(['--changeset', changeset_name])
    if args.output:
        cmd_args.extend(['--output', args.output])
    if getattr(args, 'force', False):
        cmd_args.append('--force')
    return run_script(script, cmd_args, "Build USB")

def cmd_validate(args):
    """Validate OpenCore configuration"""
    script = ROOT / "scripts" / "validate-config.py"
    cmd_args = []
    if args.config:
        cmd_args.append(args.config)
    return run_script(script, cmd_args, "Validate configuration")

def cmd_generate_smbios(args):
    """Generate SMBIOS data"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    script = ROOT / "scripts" / "generate-smbios.py"
    changeset_name = normalize_changeset_name(args.changeset)
    return run_script(script, [changeset_name], "Generate SMBIOS")

def cmd_generate_serial(args):
    """Generate serial numbers and UUIDs"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    script = ROOT / "scripts" / "generate-serial.py"
    cmd_args = []
    
    if args.changeset:
        changeset_name = normalize_changeset_name(args.changeset)
        cmd_args.append(changeset_name)
    if getattr(args, 'force', False):
        cmd_args.append('--force')
    if getattr(args, 'list', False):
        cmd_args.append('--list')
    
    return run_script(script, cmd_args, "Generate serial numbers")

def cmd_read_config(args):
    """Read existing config.plist and convert to changeset format"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    script = ROOT / "scripts" / "read-config.py"
    cmd_args = [args.config]
    
    if args.output:
        cmd_args.extend(['--output', args.output])
    
    return run_script(script, cmd_args, "Read config")

# Workflow commands
def cmd_full_usb(args):
    """Full USB workflow: changeset → ISO → USB"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    workflow = ROOT / "workflows" / "full-usb.py"
    changeset_name = normalize_changeset_name(args.changeset)
    
    cmd_args = [changeset_name]
    if args.output:
        cmd_args.extend(['--output', args.output])
    if getattr(args, 'force', False):
        cmd_args.append('--force')
    if getattr(args, 'eject', False):
        cmd_args.append('--eject')
    return run_workflow(workflow, cmd_args, "Full USB workflow")

def cmd_full_deploy(args):
    """Full deploy workflow: changeset → ISO → Proxmox"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    workflow = ROOT / "workflows" / "full-deploy.py"
    changeset_name = normalize_changeset_name(args.changeset)
    
    cmd_args = [changeset_name]
    if getattr(args, 'rebuild', False):
        cmd_args.append('--rebuild')
    if getattr(args, 'build_only', False):
        cmd_args.append('--build-only')
    return run_workflow(workflow, cmd_args, "Full deploy workflow")

def cmd_switch(args):
    """Switch changeset for testing"""
    if not check_python_env():
        warn("Python environment not ready. Run: ./ozzy setup-env")
        return False
    
    workflow = ROOT / "workflows" / "switch-changeset.py"
    changeset_name = normalize_changeset_name(args.changeset)
    
    cmd_args = [changeset_name]
    if getattr(args, 'force', False):
        cmd_args.append('--force')
    return run_workflow(workflow, cmd_args, "Switch changeset")

# Utility commands
def cmd_fetch(args):
    """Fetch OpenCore assets"""
    script = ROOT / "bin" / "fetch_assets.sh"
    try:
        result = subprocess.run(['bash', str(script)], cwd=ROOT, check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def cmd_clean(args):
    """Clean output directories"""
    import shutil
    
    out_dir = ROOT / "out"
    if out_dir.exists():
        log("Cleaning output directory...")
        for item in out_dir.iterdir():
            if item.is_dir():
                shutil.rmtree(item)
            else:
                item.unlink()
        log("Clean completed")
    else:
        info("No output directory to clean")
    return True

def cmd_setup_env(args):
    """Set up Python environment"""
    script = ROOT / "bin" / "setup_env.sh"
    try:
        result = subprocess.run(['bash', str(script)], cwd=ROOT, check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def cmd_status(args):
    """Show project status"""
    log("Project Status")
    
    # Basic info
    info(f"Project Root: {ROOT}")
    info(f"Output Directory: {ROOT / 'out'}")
    
    # Python environment
    python_ok = check_python_env()
    python_status = "✓" if python_ok else "✗"
    info(f"Python Environment: {python_status}")
    
    # Available changesets
    changesets = list_available_changesets()
    if changesets:
        log("Available Changesets:")
        for cs in sorted(changesets):
            info(f"  - {cs}")
    else:
        warn("No changesets found")
    
    # Check key files
    config_file = ROOT / "out" / "build" / "efi" / "EFI" / "OC" / "config.plist"
    config_status = "✓" if config_file.exists() else "✗"
    info(f"Current Config: {config_status} {config_file}")
    
    return True

def cmd_mount_efi(args):
    """Mount EFI partition from Install USB"""
    import subprocess
    import glob
    
    log("Mounting EFI partition from Install USB...")
    
    # Find Install volumes
    volumes_pattern = "/Volumes/Install*"
    install_volumes = []
    
    log("Scanning for Install volumes...")
    for volume_path in glob.glob(volumes_pattern):
        volume = Path(volume_path)
        if volume.exists() and volume.is_dir():
            log(f"Found Install volume: {volume}")
            install_volumes.append(volume)
    
    if not install_volumes:
        error("!!! Install USB not found -- either plug it in and try again, or check if EFI partition exists !!!")
        return False
    
    if len(install_volumes) > 1:
        warn("Multiple Install volumes found:")
        for i, volume in enumerate(install_volumes, 1):
            warn(f"  {i}. {volume}")
        warn("Using the first one found")
    
    # Use the first Install volume
    install_volume = install_volumes[0]
    log(f"Using Install volume: {install_volume}")
    
    # Get disk identifier
    try:
        result = subprocess.run(['diskutil', 'info', str(install_volume)], 
                              capture_output=True, text=True, check=True)
        
        disk_id = None
        for line in result.stdout.split('\n'):
            if 'Device Identifier:' in line:
                disk_id = line.split(':')[1].strip()
                break
                
        if not disk_id:
            error("Could not determine disk identifier")
            return False
            
    except subprocess.CalledProcessError as e:
        error(f"Failed to get disk info for {install_volume}: {e.stderr}")
        return False
    
    # Extract base disk (e.g., disk2s2 -> disk2)
    base_disk = disk_id.rsplit('s', 1)[0]
    log(f"Base disk: {base_disk}")
    
    # Check if EFI partition exists
    efi_disk_id = f"{base_disk}s1"  # EFI is usually partition 1
    
    try:
        result = subprocess.run(['diskutil', 'info', efi_disk_id], 
                              capture_output=True, text=True, check=True)
        
        # Check if it's actually an EFI partition
        is_efi = False
        for line in result.stdout.split('\n'):
            if 'File System Personality:' in line and 'FAT32' in line:
                is_efi = True
                break
            if 'Volume Name:' in line and 'EFI' in line:
                is_efi = True
                break
                
        if not is_efi:
            error("EFI partition not found on this disk")
            return False
            
    except subprocess.CalledProcessError:
        error("EFI partition not found on this disk")
        return False
    
    # Mount EFI partition
    try:
        result = subprocess.run(['sudo', 'diskutil', 'mount', efi_disk_id],
                              capture_output=True, text=True, check=True)
        
        # Check if EFI partition is mounted
        efi_mount_point = Path("/Volumes/EFI")
        if efi_mount_point.exists():
            log(f"✓ EFI partition mounted successfully at: {efi_mount_point}")
            info(f"You can now access the EFI partition at: {efi_mount_point}")
            
            # Show current EFI contents if it exists
            efi_folder = efi_mount_point / "EFI"
            if efi_folder.exists():
                log("Current EFI structure:")
                try:
                    result = subprocess.run(['find', str(efi_folder), '-maxdepth', '2'], 
                                          capture_output=True, text=True, check=True)
                    for line in result.stdout.strip().split('\n'):
                        if line != str(efi_folder):
                            relative_path = line.replace(str(efi_folder), '').lstrip('/')
                            if relative_path:
                                info(f"  {relative_path}")
                except subprocess.CalledProcessError:
                    pass
            else:
                info("EFI folder not found on this partition")
            
            return True
        else:
            error("EFI partition mounted but /Volumes/EFI not found")
            return False
            
    except subprocess.CalledProcessError as e:
        error(f"Failed to mount EFI partition {efi_disk_id}: {e.stderr}")
        return False

def cmd_list(args):
    """List available changesets"""
    changesets = list_available_changesets()
    if changesets:
        log("Available changesets:")
        for cs in sorted(changesets):
            info(f"  - {cs}")
    else:
        warn("No changesets found")
    return True

def main():
    parser = argparse.ArgumentParser(
        description='Ozzy - OpenCore Remote Deploy Master Script',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Core Commands:
  apply              Apply a changeset to OpenCore configuration
  build-iso          Build OpenCore ISO
  build-usb          Build USB EFI structure
  validate           Validate OpenCore configuration

Workflow Commands (Main Use Cases):
  full-usb           Changeset → ISO → USB in one command
  full-deploy        Changeset → ISO → Proxmox in one command
  switch             Switch to different changeset for testing

Utility Commands:
  generate-smbios    Generate SMBIOS data for changeset
  generate-serial    Generate serial numbers and UUIDs
  read-config        Convert existing config.plist to changeset format
  fetch              Fetch OpenCore assets
  clean              Clean output directories
  setup-env          Set up Python environment
  status             Show project status
  list               List available changesets

Examples:
  ./ozzy full-usb myconfig --output ./usb
  ./ozzy full-deploy myconfig --rebuild
  ./ozzy switch testconfig
  ./ozzy generate-serial myconfig --force
  ./ozzy read-config ./path/to/config.plist --output myconfig.yaml
  ./ozzy apply myconfig && ./ozzy build-iso
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Core commands
    apply_parser = subparsers.add_parser('apply', help='Apply changeset')
    apply_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    
    build_iso_parser = subparsers.add_parser('build-iso', help='Build ISO')
    build_iso_parser.add_argument('--force', '-f', action='store_true', help='Force rebuild')
    
    build_usb_parser = subparsers.add_parser('build-usb', help='Build USB')
    build_usb_parser.add_argument('--changeset', '-c', help='Changeset to apply')
    build_usb_parser.add_argument('--output', '-o', help='Output directory')
    build_usb_parser.add_argument('--force', '-f', action='store_true', help='Force rebuild')
    
    validate_parser = subparsers.add_parser('validate', help='Validate config')
    validate_parser.add_argument('config', nargs='?', help='Config file path')
    
    smbios_parser = subparsers.add_parser('generate-smbios', help='Generate SMBIOS')
    smbios_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    
    # Serial generation command
    serial_parser = subparsers.add_parser('generate-serial', help='Generate serial numbers')
    serial_parser.add_argument('changeset', nargs='?', help='Changeset name (without .yaml)')
    serial_parser.add_argument('--force', '-f', action='store_true', help='Force regeneration')
    serial_parser.add_argument('--list', '-l', action='store_true', help='List existing serials')
    
    # Config reading command
    read_config_parser = subparsers.add_parser('read-config', help='Convert config.plist to changeset')
    read_config_parser.add_argument('config', help='Path to config.plist file')
    read_config_parser.add_argument('--output', '-o', help='Output changeset file')
    
    # Workflow commands
    full_usb_parser = subparsers.add_parser('full-usb', help='Full USB workflow')
    full_usb_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    full_usb_parser.add_argument('--output', '-o', help='Output directory')
    full_usb_parser.add_argument('--force', '-f', action='store_true', help='Force rebuild')
    full_usb_parser.add_argument('--eject', action='store_true', help='Automatically eject EFI and Install volumes')
    
    full_deploy_parser = subparsers.add_parser('full-deploy', help='Full deploy workflow')
    full_deploy_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    full_deploy_parser.add_argument('--rebuild', '-r', action='store_true', help='Force rebuild')
    full_deploy_parser.add_argument('--build-only', '-b', action='store_true', help='Build only')
    
    switch_parser = subparsers.add_parser('switch', help='Switch changeset')
    switch_parser.add_argument('changeset', help='Changeset name (without .yaml)')
    switch_parser.add_argument('--force', '-f', action='store_true', help='Skip confirmation')
    
    # Utility commands
    fetch_parser = subparsers.add_parser('fetch', help='Fetch assets')
    clean_parser = subparsers.add_parser('clean', help='Clean outputs')
    setup_parser = subparsers.add_parser('setup-env', help='Setup environment')
    status_parser = subparsers.add_parser('status', help='Show status')
    list_parser = subparsers.add_parser('list', help='List changesets')
    mount_efi_parser = subparsers.add_parser('mount-efi', help='Mount EFI partition from Install USB')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    # Command mapping
    commands = {
        'apply': cmd_apply,
        'build-iso': cmd_build_iso,
        'build-usb': cmd_build_usb,
        'validate': cmd_validate,
        'generate-smbios': cmd_generate_smbios,
        'generate-serial': cmd_generate_serial,
        'read-config': cmd_read_config,
        'full-usb': cmd_full_usb,
        'full-deploy': cmd_full_deploy,
        'switch': cmd_switch,
        'fetch': cmd_fetch,
        'clean': cmd_clean,
        'setup-env': cmd_setup_env,
        'status': cmd_status,
        'list': cmd_list,
        'mount-efi': cmd_mount_efi,
    }
    
    cmd_func = commands.get(args.command)
    if not cmd_func:
        error(f"Unknown command: {args.command}")
        return 1
    
    try:
        success = cmd_func(args)
        return 0 if success else 1
    except KeyboardInterrupt:
        warn("Operation cancelled by user")
        return 1
    except Exception as e:
        error(f"Command failed: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())
