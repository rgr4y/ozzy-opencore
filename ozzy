#!/usr/bin/env python3.11
"""
Ozzy - macOS OpenCore Remote Deploy Master Script

A lean command orchestrator that delegates to specialized scripts and workflows.
Focused on the core use cases: apply changesets, build ISOs/USBs, deploy to Proxmox.
"""

import sys
import subprocess
import argparse
from pathlib import Path

# Add lib directory to path
sys.path.insert(0, str(Path(__file__).resolve().parent / 'lib'))

# Import basic utilities
from lib import ROOT, log, warn, error, info, list_available_changesets, list_newest_changesets

def run_script(script_path, args_list, description):
    """Run a script with the given arguments"""
    cmd = [sys.executable, str(script_path)] + args_list
    log(f"Running: {' '.join(cmd)}")
    
    try:
        result = subprocess.run(cmd, cwd=ROOT, check=True)
        return True
    except subprocess.CalledProcessError as e:
        error(f"{description} failed with exit code {e.returncode}")
        return False
    except Exception as e:
        error(f"Failed to run {description}: {e}")
        return False

def check_python_env():
    """Check if Python environment has required packages"""
    try:
        import yaml
        import plistlib
        return True
    except ImportError:
        return False

def normalize_changeset_name(changeset_name):
    """Strip .yaml extension from changeset name if present"""
    if changeset_name.endswith('.yaml'):
        return changeset_name[:-5]
    return changeset_name

def requires_python_env(func):
    """Decorator to check Python environment before running command"""
    def wrapper(*args, **kwargs):
        if not check_python_env():
            warn("Python environment not ready. Run: ./ozzy setup-env")
            return False
        return func(*args, **kwargs)
    return wrapper

def build_script_args(args, base_args=None, extra_args=None, flags=None, changeset_first=True):
    """Build command arguments from args object with common patterns"""
    cmd_args = list(base_args) if base_args else []
    
    # Add changeset if present and should be first
    if changeset_first and hasattr(args, 'changeset') and args.changeset:
        changeset_name = normalize_changeset_name(args.changeset)
        cmd_args.insert(0, changeset_name)
    
    # Add output if present
    if hasattr(args, 'output') and args.output:
        cmd_args.extend(['--output', args.output])
    
    # Add common flags
    if flags:
        for flag in flags:
            if getattr(args, flag.replace('-', '_'), False):
                cmd_args.append(f'--{flag}')
    
    # Add any extra arguments
    if extra_args:
        cmd_args.extend(extra_args)
    
    return cmd_args

def run_script_command(script_path, args, description, base_args=None, extra_args=None, flags=None, changeset_first=True):
    """Run a script with standardized argument handling"""
    cmd_args = build_script_args(args, base_args, extra_args, flags, changeset_first)
    return run_script(script_path, cmd_args, description)

# Command implementations
@requires_python_env
def cmd_apply(args, extra_args=None):
    """Apply a changeset to OpenCore configuration"""
    script = ROOT / "scripts" / "apply-changeset.py"
    changeset_name = normalize_changeset_name(args.changeset)
    cmd_args = [changeset_name]
    if extra_args:
        cmd_args.extend(extra_args)
    return run_script(script, cmd_args, "Apply changeset")

@requires_python_env
def cmd_build_iso(args):
    """Build OpenCore ISO"""
    script = ROOT / "scripts" / "build-iso.py"
    return run_script_command(script, args, "Build ISO", 
                             flags=['force', 'no-validate'])

@requires_python_env
def cmd_build_usb(args):
    """Build USB EFI structure"""
    script = ROOT / "scripts" / "build-usb.py"
    return run_script_command(script, args, "Build USB", 
                             flags=['force'])

def cmd_validate(args):
    """Validate OpenCore configuration"""
    script = ROOT / "scripts" / "validate-config.py"
    cmd_args = [args.config] if args.config else []
    return run_script(script, cmd_args, "Validate configuration")

@requires_python_env
def cmd_generate_smbios(args):
    """Generate SMBIOS data"""
    script = ROOT / "scripts" / "generate-serial.py"
    return run_script_command(script, args, "Generate SMBIOS", 
                             flags=['force'])

@requires_python_env
def cmd_generate_serial(args):
    """Generate serial numbers and UUIDs"""
    script = ROOT / "scripts" / "generate-serial.py"
    cmd_args = []
    
    if args.changeset:
        changeset_name = normalize_changeset_name(args.changeset)
        cmd_args.append(changeset_name)
    
    # Add flags
    for flag in ['force', 'list', 'serial-only', 'rom-uuid-only']:
        attr_name = flag.replace('-', '_')
        if getattr(args, attr_name, False):
            cmd_args.append(f'--{flag}')
    
    return run_script(script, cmd_args, "Generate serial numbers")

@requires_python_env
def cmd_read_config(args):
    """Read existing config.plist and convert to changeset format"""
    script = ROOT / "scripts" / "read-config.py"
    return run_script_command(script, args, "Read config", 
                             base_args=[args.config], changeset_first=False)

# Workflow commands
@requires_python_env
def cmd_full_usb(args):
    """Full USB workflow: changeset → ISO → USB"""
    workflow = ROOT / "workflows" / "full-usb.py"
    return run_script_command(workflow, args, "Full USB workflow", 
                             flags=['force', 'eject'])

@requires_python_env
def cmd_full_deploy(args):
    """Full deploy workflow: changeset → IMG/ISO → Proxmox"""
    # Validate argument combinations
    if getattr(args, 'iso_only', False) and getattr(args, 'force', False):
        error("Cannot use --iso-only and --force together. --iso-only skips the apply step, making --force redundant.")
        return False
    
    workflow = ROOT / "workflows" / "full-deploy.py"
    return run_script_command(workflow, args, "Full deploy workflow", 
                             flags=['force', 'build-only', 'iso-only', 'iso'])

@requires_python_env
def cmd_switch(args):
    """Switch changeset for testing"""
    workflow = ROOT / "workflows" / "switch-changeset.py"
    return run_script_command(workflow, args, "Switch changeset", 
                             flags=['force'])

# Utility commands
def cmd_fetch(args):
    """Fetch OpenCore assets"""
    script = ROOT / "scripts" / "fetch-assets.py"
    return run_script(script, [], "Fetch assets")

def cmd_clean(args):
    """Clean output directories"""
    import shutil
    
    out_dir = ROOT / "out"
    if out_dir.exists():
        log("Cleaning output directory...")
        for item in out_dir.iterdir():
            if item.is_dir():
                shutil.rmtree(item)
            else:
                item.unlink()
        log("Clean completed")
    else:
        info("No output directory to clean")
    return True

def cmd_setup_env(args):
    """Set up Python environment"""
    script = ROOT / "bin" / "setup_env.sh"
    try:
        result = subprocess.run(['bash', str(script)], cwd=ROOT, check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def display_changesets(changesets, title="Available changesets"):
    """Display a list of changesets in a consistent format"""
    if changesets:
        log(f"{title}:")
        for cs in sorted(changesets):
            info(f"  - {cs}")
    else:
        warn("No changesets found")

def cmd_status(args):
    """Show project status"""
    log("Project Status")
    
    # Basic info
    info(f"Project Root: {ROOT}")
    info(f"Output Directory: {ROOT / 'out'}")
    
    # Python environment
    python_ok = check_python_env()
    python_status = "✓" if python_ok else "✗"
    info(f"Python Environment: {python_status}")
    
    # Available changesets
    changesets = list_available_changesets()
    display_changesets(changesets)
    
    # Check key files
    config_file = ROOT / "out" / "build" / "efi" / "EFI" / "OC" / "config.plist"
    config_status = "✓" if config_file.exists() else "✗"
    info(f"Current Config: {config_status} {config_file}")
    
    return True

def cmd_mount_efi(args):
    """Mount EFI partition from Install USB or USB drives with EFI partitions"""
    import subprocess
    import glob
    
    log("Scanning for USB drives with EFI partitions...")
    
    # First priority: Find Install volumes
    volumes_pattern = "/Volumes/Install*"
    install_volumes = []
    
    log("Scanning for Install volumes...")
    for volume_path in glob.glob(volumes_pattern):
        volume = Path(volume_path)
        if volume.exists() and volume.is_dir():
            log(f"Found Install volume: {volume}")
            install_volumes.append(volume)
    
    # If Install volumes found, use them (original behavior)
    if install_volumes:
        if len(install_volumes) > 1:
            log("Multiple Install volumes found:")
            for i, volume in enumerate(install_volumes, 1):
                log(f"  {i}. {volume}")
            log("Using the first one found")
        
        # Use the first Install volume
        install_volume = install_volumes[0]
        log(f"Using Install volume: {install_volume}")
        
        # Get disk identifier
        try:
            result = subprocess.run(['diskutil', 'info', str(install_volume)], 
                                  capture_output=True, text=True, check=True)
            
            disk_id = None
            for line in result.stdout.split('\n'):
                if 'Device Identifier:' in line:
                    disk_id = line.split(':')[1].strip()
                    break
                    
            if not disk_id:
                error("Could not determine disk identifier")
                return False
                
        except subprocess.CalledProcessError as e:
            error(f"Failed to get disk info for {install_volume}: {e.stderr}")
            return False
        
        # Extract base disk (e.g., disk2s2 -> disk2)
        selected_disk = disk_id.rsplit('s', 1)[0]
        log(f"Using disk from Install volume: {selected_disk}")
        
    else:
        # Fallback: Look for USB drives with EFI partitions only
        log("No Install volumes found, scanning for USB drives with EFI partitions...")
        usb_disks = []
        
        try:
            # Get list of all disks
            result = subprocess.run(['diskutil', 'list'], capture_output=True, text=True, check=True)
            
            # Parse diskutil output to find USB/external disks
            current_disk = None
            for line in result.stdout.split('\n'):
                line = line.strip()
                if line.startswith('/dev/disk'):
                    current_disk = line.split()[0].replace('/dev/', '')
                elif current_disk and ('external' in line.lower() or 'usb' in line.lower()):
                    # Get detailed info about this disk
                    try:
                        disk_info = subprocess.run(['diskutil', 'info', current_disk], 
                                                 capture_output=True, text=True, check=True)
                        
                        # Check if it's removable/external (USB only, not internal drives)
                        is_removable = False
                        protocol_usb = False
                        for info_line in disk_info.stdout.split('\n'):
                            if 'Removable Media:' in info_line and 'Yes' in info_line:
                                is_removable = True
                            if 'Protocol:' in info_line and 'USB' in info_line:
                                protocol_usb = True
                        
                        # Only consider USB drives, not other external drives like Thunderbolt
                        if is_removable and protocol_usb:
                            # Check if this disk has an EFI partition (s1)
                            efi_partition = f"{current_disk}s1"
                            try:
                                efi_info = subprocess.run(['diskutil', 'info', efi_partition], 
                                                        capture_output=True, text=True, check=True)
                                
                                # Check if it's an EFI partition
                                is_efi = False
                                for efi_line in efi_info.stdout.split('\n'):
                                    if ('File System Personality:' in efi_line and 'FAT32' in efi_line) or \
                                       ('Volume Name:' in efi_line and 'EFI' in efi_line) or \
                                       ('Partition Type:' in efi_line and 'EFI' in efi_line):
                                        is_efi = True
                                        break
                                
                                if is_efi:
                                    log(f"Found USB drive with EFI partition: {current_disk}")
                                    usb_disks.append(current_disk)
                                    
                            except subprocess.CalledProcessError:
                                # No EFI partition found on this disk
                                pass
                                
                    except subprocess.CalledProcessError:
                        # Failed to get disk info
                        pass
                        
        except subprocess.CalledProcessError as e:
            warn(f"Failed to scan for USB drives: {e}")
        
        if not usb_disks:
            error("!!! No Install USB or USB drives with EFI partitions found !!!")
            error("    Either plug in a USB drive with an EFI partition, or check if EFI partition exists")
            return False
        
        # Select USB disk to use
        if len(usb_disks) > 1:
            log("Multiple USB drives with EFI partitions found:")
            for i, disk in enumerate(usb_disks, 1):
                log(f"  {i}. USB drive: /dev/{disk}")
            log("Using the first one found")
        
        selected_disk = usb_disks[0]
        log(f"Using USB drive: {selected_disk}")
    
    # Common EFI mounting logic for both Install volumes and USB drives
    
    log(f"Using disk: {selected_disk}")
    
    # Check if EFI partition exists
    efi_disk_id = f"{selected_disk}s1"  # EFI is usually partition 1
    
    try:
        result = subprocess.run(['diskutil', 'info', efi_disk_id], 
                              capture_output=True, text=True, check=True)
        
        # Check if it's actually an EFI partition
        is_efi = False
        for line in result.stdout.split('\n'):
            if 'File System Personality:' in line and 'FAT32' in line:
                is_efi = True
                break
            if 'Volume Name:' in line and 'EFI' in line:
                is_efi = True
                break
                
        if not is_efi:
            error("EFI partition not found on this disk")
            return False
            
    except subprocess.CalledProcessError:
        error("EFI partition not found on this disk")
        return False
    
    # Mount EFI partition
    try:
        result = subprocess.run(['sudo', 'diskutil', 'mount', efi_disk_id],
                              capture_output=True, text=True, check=True)
        
        # Check if EFI partition is mounted
        efi_mount_point = Path("/Volumes/EFI")
        if efi_mount_point.exists():
            log(f"✓ EFI partition mounted successfully at: {efi_mount_point}")
            info(f"You can now access the EFI partition at: {efi_mount_point}")
            
            # Show current EFI contents if it exists
            efi_folder = efi_mount_point / "EFI"
            if efi_folder.exists():
                log("Current EFI structure:")
                try:
                    result = subprocess.run(['find', str(efi_folder), '-maxdepth', '2'], 
                                          capture_output=True, text=True, check=True)
                    for line in result.stdout.strip().split('\n'):
                        if line != str(efi_folder):
                            relative_path = line.replace(str(efi_folder), '').lstrip('/')
                            if relative_path:
                                info(f"  {relative_path}")
                except subprocess.CalledProcessError:
                    pass
            else:
                info("EFI folder not found on this partition")
            
            return True
        else:
            error("EFI partition mounted but /Volumes/EFI not found")
            return False
            
    except subprocess.CalledProcessError as e:
        error(f"Failed to mount EFI partition {efi_disk_id}: {e.stderr}")
        return False

def cmd_list(args):
    """List available changesets"""
    changesets = list_available_changesets()
    display_changesets(changesets)
    return True

@requires_python_env
def cmd_test(args):
    """Run the test suite"""
    test_runner = ROOT / "tests" / "run-tests.py"
    return run_script(test_runner, [], "Test suite")

def main():
    """Thin command runner that delegates to scripts/workflows.

    Help for script-backed commands is shown by the scripts themselves.
    """
    # Map commands to underlying scripts/workflows
    script_commands = {
        # Core
        'apply': ROOT / 'scripts' / 'apply-changeset.py',
        'build-iso': ROOT / 'scripts' / 'build-iso.py',
        'build-usb': ROOT / 'scripts' / 'build-usb.py',
        'validate': ROOT / 'scripts' / 'validate-config.py',
        'generate-smbios': ROOT / 'scripts' / 'generate-serial.py',
        'generate-serial': ROOT / 'scripts' / 'generate-serial.py',
        'read-config': ROOT / 'scripts' / 'read-config.py',
        # Workflows
        'full-usb': ROOT / 'workflows' / 'full-usb.py',
        'full-deploy': ROOT / 'workflows' / 'full-deploy.py',
        'switch': ROOT / 'workflows' / 'switch-changeset.py',
    }

    builtin_commands = {
        'fetch': cmd_fetch,
        'clean': cmd_clean,
        'setup-env': cmd_setup_env,
        'status': cmd_status,
        'list': cmd_list,
        'mount-efi': cmd_mount_efi,
        'test': cmd_test,
    }

    argv = sys.argv[1:]
    if not argv or argv[0] in ('-h', '--help'):
        # Minimal top-level help without duplicating per-script usage
        print("Usage: ./ozzy <command> [args]\n")
        print("Script-backed commands (use --help on them):")
        for name in sorted(script_commands.keys()):
            print(f"  {name}")
        print("\nBuilt-in commands:")
        for name in sorted(builtin_commands.keys()):
            print(f"  {name}")
        print("\nExamples:\n  ./ozzy full-deploy myconfig --force\n  ./ozzy build-iso myconfig --no-validate\n  ./ozzy build-usb myconfig --output ./usb\n  ./ozzy generate-serial myconfig --serial-only\n  ./ozzy read-config ./config.plist --output my.yaml\n  ./ozzy <command> --help  # Show script-specific help")
        return 0

    command = argv[0]
    rest = argv[1:]

    # Dispatch to built-in commands
    if command in builtin_commands:
        try:
            return 0 if builtin_commands[command](argparse.Namespace()) else 1
        except KeyboardInterrupt:
            warn("Operation cancelled by user")
            return 1
        except Exception as e:
            error(f"Command failed: {e}")
            return 1

    # Dispatch to script-backed commands
    script_path = script_commands.get(command)
    if not script_path:
        error(f"Unknown command: {command}")
        info("Run './ozzy --help' to see available commands")
        return 1

    # If no args for a script-backed command, show that script's help
    if len(rest) == 0:
        rest = ['--help']

    return 0 if run_script(script_path, rest, f"{command}") else 1

if __name__ == '__main__':
    sys.exit(main())
